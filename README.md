### Загальний опис
Цей бот призначений для ролі менеджера ресторану, який надає клієнтам інформацію з меню та оформлює замовлення на доставку. 
Була розроблена RAG-система, що включає 
1. Попередньонавчений **DistilBertForSequenceClassification**
2. **Hybrid search** (**sparse + dense вектори** з rerank за допомогою **late-interaction модель**)
3. **Мультиагентну архітектуру** (є 2 окремих агента: 1- відповідає клієнту, 2 - визначає статус переписки на чи готова людина замовляти).

### Вхідні дані:
API меню ресторану з полями: **назва, ціна, опис та id**.

### Підготовка:
**Проблема 1:**
В проєкті використовується sparse-пошук, а в API був лише опис продукту, який дає розмите уявлення, 
**Рішення:**
Я створив окремий обробник, який витягує з опису **ключові слова** про продукт (яка кухня, особливості, інгредієнти тощо). На основі цих ключових слів формувалися sparse-вектори. 

**Проблема 2:**
В якості моделі кодування використовувався **BM25**, але в ньому не було підтримки української мови. 
**Рішення:**
Для цього я зробив власний препроцесор, який надає **BM25** дані у потрібному форматі.

Також, з метою звузити задачі для основного агента, був створений класифікатор, який перенаправляє скарги та пропозиції щодо співпраці іншим агентам. Для навчання цього класифікатора я використовував синтетичні дані, згенеровані GPT. Навчену модель збережено локально для подальшого використання.

### Алгоритм роботи бота:

1. При **першому зверненні** користувача навчена модель **DistilBertForSequenceClassification** визначає, до якої категорії належить запит користувача: замовлення, скарги чи співпраця.
2. Залежно від визначеної категорії виконуються різні дії. Якщо категорія — **скарги або співпраця**, **надсилається заздалегідь підготовлене повідомлення** з контактами відповідних відділів компанії. Якщо це **замовлення — **викликається основний агент**.

### Логіка роботи основного агента:

1. При запиті агент збирає історію повідомлень чату з бази даних.
2. Далі, на основі історії повідомлень і останнього запиту користувача, формується окремий запит до векторної БД (метод **Rag Fusion**).
3. З векторної бази витягуються: **3 документи з dense пошуку, 3 - з sparse пошуку та 4 - з late-interaction моделі** (з топ-20 результатів dense і sparse). Таким чином отримується релевантний контекст.
4. Далі агенту передається **prompt з інструкцією для спілкування з користувачем, історія повідомлень і контекст, отриманий з векторної БД**.
5. Коли користувач підтверджує доставку, інший агент, який слідкує за чатом, викликає функцію `extract_delivery_info`, яка повертає у структурованому форматі (схема `DeliveryInfo`) інформацію для оформлення доставки.


### Результати:

Завдяки такому пайплайну вдається досягати достойних результатів, навіть використовуючи не найпотужнішу модель (`gpt-4o-mini`).

### Технічні деталі:

В якості векторної бази даних використовується: `Qdrant`.
Промпти, за можливості, бралися з `LangSmith`.